@group(0) @binding(0) var<uniform> uMyUniforms: MyUniforms;
@group(1) @binding(0) var<storage,read> inbuf_tet_precomp: array<TetPrecomputeData>;
@group(2) @binding(0) var<storage,read> inbuf_tet_precomp_viewdep : array<TetPrecomputeDataViewDep>;

struct TRange {
    first: f32, // t value of first intersection
    last: f32,  // t value of last intersection
};

fn update_t_range(_range: TRange, nom: f32, denom: f32) -> TRange {
    var range = _range;
    let is_back = nom > 0.;
    if (is_back) {
        range.last = min(range.last, nom/denom);
    } else {
        range.first = max(range.first, nom/denom);
    }
    return range;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
	// Combine texture and lighting
    
    let pci = inbuf_tet_precomp[in.tet_id];
    let pcd = inbuf_tet_precomp_viewdep[in.tet_id];


    let campos = uMyUniforms.camera_in_object_space;
    let view = in.position_model.xyz - campos;
    let viewdir = normalize(in.position_model.xyz - campos);

    let t_nom = pcd.cramer_t_nom;
    let t_denom = -viewdir * mat4x3<f32>(pci.baca, pci.cdbd, pci.cada, pci.daba);

    var t_range : TRange;
    t_range.first = -1e38;
    t_range.last = 1e38;
    for (var i:i32 = 0; i < 4;i++) {
        t_range = update_t_range(t_range, t_nom[i], t_denom[i]);
    }
    let depth = (t_range.last - t_range.first);

    let scale = 10.; //0.001;
    let val = clamp(depth*scale, 0., 1.);

	var color = vec3<f32>(1.-val, val, clamp(depth/10., 0., 10.));
    //color = clamp(pcd.cramer_t_nom.xyz*100000., vec3<f32>(0.), vec3<f32>(1.));

	// Gamma-correction
	let corrected_color = pow(color, vec3<f32>(2.2));
	return vec4<f32>(corrected_color, uMyUniforms.color.a);
}

