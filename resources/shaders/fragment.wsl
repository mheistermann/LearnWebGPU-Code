@group(0) @binding(0) var<uniform> uMyUniforms: MyUniforms;
@group(1) @binding(0) var<storage,read> inbuf_tet_precomp: array<TetPrecomputeData>;
@group(2) @binding(0) var<storage,read> inbuf_tet_precomp_viewdep : array<TetPrecomputeDataViewDep>;

struct Fract {
    nom: f32,
    denom: f32,
};

fn val(f: Fract) -> f32 {
    return f.nom / f.denom;
};
struct TRange {
    first: Fract, // t value of first intersection
    last: Fract,  // t value of last intersection
};

/// this assumes that sign(left.d) == sign(right.d)!
fn less(l: Fract, r: Fract) -> bool {
    // l.n / l.d <= r.n / r.d
    // l.n * r.d<= r.n * l.d
    return l.nom * r.denom <= r.nom * l.denom;
}

fn update_t_range(_range: TRange, tf: Fract) -> TRange {
    var range = _range;
    let eps = -1.; // for debug/tests
    if (tf.nom > eps) { // back face?
        if (tf.denom > eps) { // intersection in front of camera>?
            //     tf.n / tf.d <= r.n / r.d
            // <=> tf.n * r.d <= r.n * tf.d
            //let r = range.last;
            //if(tf.nom * r.denom <= r.nom * tf.denom) {
            if(less(tf, range.last)) {
                range.last = tf;
            }
        }
    } else if (tf.nom < (-eps)) { // back face?
        if (tf.denom < (-eps))
        { // intersection in front of camera?
            // all denoms will be negative
            //let r = range.first;
            //if(tf.nom * r.denom >= r.nom * tf.denom) {
            if(less(range.first, tf)){
            //if (less(range.first, tf)) {
                range.first = tf;
            }
        }
    }
    return range;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
	// Combine texture and lighting
    
    let pci = inbuf_tet_precomp[in.tet_id];
    let pcd = inbuf_tet_precomp_viewdep[in.tet_id];


    let campos = uMyUniforms.camera_in_object_space;
    let view = in.position_model.xyz - campos;
    let viewdir = normalize(in.position_model.xyz - campos);

    let t_nom = pcd.cramer_t_nom;
    let t_denom = -viewdir * mat4x3<f32>(pci.baca, pci.cdbd, pci.cada, pci.daba);

    var t_range : TRange;
    t_range.first.nom = 1e5;
    t_range.first.denom = -1.;
    t_range.last.nom = 1e5;
    t_range.last.denom = 1.;
    for (var i:i32 = 0; i < 4;i++) {
        t_range = update_t_range(t_range, Fract(t_nom[i], t_denom[i]));
    }
    let depth = (val(t_range.last) - val(t_range.first));
    //let depth = val(t_range.last); // DEBUG
    //let depth = val(t_range.first); // DEBUG

    //let scale = 1.; //0.001;
    let scale = 10.; //0.001;
    let vistmp = clamp(depth*scale, 0., 1.);

	var color = vec3<f32>(1.-vistmp, vistmp, clamp(-depth*scale, 0., 1.));
    let absorp = 0.5;
    //let vistmp = pow(absorp, vistmp);
	//var color = vec3<f32>(val, 1., 1.);
    //color = clamp(pcd.cramer_t_nom.xyz*100000., vec3<f32>(0.), vec3<f32>(1.));

	// Gamma-correction
    //let gamma = 2.2;
    let gamma = 1.;
	let corrected_color = pow(color, vec3<f32>(gamma));
	return vec4<f32>(corrected_color, uMyUniforms.color.a);
}

