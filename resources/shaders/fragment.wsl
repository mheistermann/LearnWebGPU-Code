@group(0) @binding(0) var<uniform> uMyUniforms: MyUniforms;
@group(1) @binding(0) var<storage,read> inbuf_tet_precomp: array<TetPrecomputeData>;
@group(2) @binding(0) var<storage,read> inbuf_tet_precomp_viewdep : array<TetPrecomputeDataViewDep>;

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
	// Combine texture and lighting
    
    let pci = inbuf_tet_precomp[in.tet_id];
    let pcd = inbuf_tet_precomp_viewdep[in.tet_id];


    let campos = uMyUniforms.camera_in_object_space;
    let view = in.position_model.xyz - campos;
    let viewdir = normalize(in.position_model.xyz - campos);

    let t_nom = pcd.cramer_t_nom;
    let t_denom = -viewdir * mat4x3<f32>(pci.baca, pci.cdbd, pci.cada, pci.daba);
    let abc_t = t_nom[0] / dot(pci.baca, -viewdir);
    let dcb_t = t_nom[1] / dot(pci.cdbd, -viewdir);
    let acd_t = t_nom[2] / dot(pci.cada, -viewdir);
    let adb_t = t_nom[3] / dot(pci.daba, -viewdir);
    

    let is_back = t_nom > vec4<f32>(0.);

    let scale = 0.2;
    var val = clamp(length(view)*scale, 0., 1.);
    //val = clamp(abc_t, 0., 1.);
    val = clamp(pcd.cramer_t_nom[1]*1000., 0., 1.);
    val = select(0., 1., is_back[1]);
    val = clamp(dcb_t*.1, 0., 1.);

	var color = vec3<f32>(1.-val, val, 0.);
    //color = clamp(pcd.cramer_t_nom.xyz*100000., vec3<f32>(0.), vec3<f32>(1.));

	// Gamma-correction
	let corrected_color = pow(color, vec3<f32>(2.2));
	return vec4<f32>(corrected_color, uMyUniforms.color.a);
}

